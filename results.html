<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Results | Root Values Survey</title>

  <link rel="stylesheet" href="styles.css" />

  <!-- Plotly + PapaParse -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#0b1220; color:#e6edf3; }
    .container { max-width: 1000px; margin: 32px auto; padding: 0 16px; }
    .topnav a { color:#9ecbff; text-decoration:none; }
    .hero h1 { margin: 8px 0 0; font-size: 40px; }
    .lead { margin: 8px 0 0; color:#a7b3c7; }
    .card { background: #0f1629; border: 1px solid #1f2a44; border-radius: 16px; padding: 16px; box-shadow: 0 10px 30px rgba(0,0,0,.25); margin-top: 20px; }
    footer { opacity:.8; margin: 32px 0 0; font-size: .9rem; }
    #diag { font-size:.95rem; color:#94a3b8; margin-top: 6px; white-space: pre-wrap; }
  </style>
</head>

<body>
  <div class="container">
    <p class="topnav"><a href="index.html">← Back to Home</a></p>

    <div class="hero">
      <h1>Results — Root Values Survey</h1>
      <p class="lead" id="lead">Loading results…</p>
      <p class="lead" id="diag"></p>
    </div>

    <div class="card">
      <div id="aggregate-plot" style="height:520px"></div>
    </div>

    <footer>
      <p>© 2025 UCD Digital Society | MIS20070 Group Project</p>
    </footer>
  </div>

<script>
(async () => {
  // ✅ Your published-to-web CSV URL
  const DATA_URL =
    'https://docs.google.com/spreadsheets/d/e/2PACX-1vQSjfZcJk_DpHaI3vcRK4czAhG8KvvBzGvX0F1yNPnqWPymSzqt7w3TrPD5ry212dXO--bMjIgSonHW/pub?gid=0&single=true&output=csv';

  const leadEl = document.getElementById('lead');
  const diagEl = document.getElementById('diag');

  const mean = a => a.length ? a.reduce((x,y)=>x+y,0)/a.length : 0;

  function toTernaryTriple(a,b,c){
    let A=+a||0, B=+b||0, C=+c||0;
    const s = A+B+C;
    if (s === 0) return {a:0,b:0,c:0};
    if (s > 1.5) { A/=100; B/=100; C/=100; }
    const t = A+B+C;
    return { a: A/t, b: B/t, c: C/t };
  }

  function randomSampleIndices(n, k){
    const idx = Array.from({length:n}, (_,i)=>i);
    for (let i=idx.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [idx[i], idx[j]] = [idx[j], idx[i]];
    }
    return idx.slice(0, Math.min(k, n));
  }

  // 1) Fetch CSV
  let csvText = '';
  try {
    const res = await fetch(DATA_URL, { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP '+res.status);
    csvText = await res.text();
    diagEl.textContent = 'Fetching: ' + DATA_URL;
  } catch (err) {
    leadEl.textContent = '⚠️ Could not load data: ' + (err.message || err);
    return;
  }

  // 2) Parse CSV
  const parsed = Papa.parse(csvText, { header: true, dynamicTyping: true, skipEmptyLines: true });
  const fields = parsed.meta.fields || [];
  const rows = parsed.data || [];

  const need = ['today_a','today_b','today_c','y2075_a','y2075_b','y2075_c'];
  const norm = k => String(k).toLowerCase().replace(/[#\s\-\.\(\)]/g,'');
  const byNorm = Object.fromEntries(fields.map(f => [norm(f), f]));
  const headerMap = {
    today_a: byNorm['todaya'] || 'today_a',
    today_b: byNorm['todayb'] || 'today_b',
    today_c: byNorm['todayc'] || 'today_c',
    y2075_a: byNorm['y2075a'] || 'y2075_a',
    y2075_b: byNorm['y2075b'] || 'y2075_b',
    y2075_c: byNorm['y2075c'] || 'y2075_c',
  };

  const missing = need.filter(k => !fields.includes(headerMap[k]));
  diagEl.textContent += '\nDetected columns: ' + (fields.join(' · ') || '— none —')
    + (missing.length ? '\nMissing: ' + missing.join(', ') : '');

  if (missing.length){
    leadEl.textContent = '⚠️ Column names not recognised. Expected: ' + need.join(', ');
    Plotly.newPlot('aggregate-plot', [], {
      ternary:{ sum:1, aaxis:{title:'Autonomy'}, baxis:{title:'Equality'}, caxis:{title:'Knowledge Integrity'} },
      paper_bgcolor:'rgba(0,0,0,0)', plot_bgcolor:'rgba(0,0,0,0)', font:{color:'#e9edf7'}
    }, {responsive:true});
    return;
  }

  // 3) Build arrays
  const tA=[], tB=[], tC=[], fA=[], fB=[], fC=[];
  for (const r of rows){
    const t = toTernaryTriple(r[headerMap.today_a], r[headerMap.today_b], r[headerMap.today_c]);
    const f = toTernaryTriple(r[headerMap.y2075_a], r[headerMap.y2075_b], r[headerMap.y2075_c]);
    if (Number.isFinite(t.a) && Number.isFinite(t.b) && Number.isFinite(t.c) &&
        Number.isFinite(f.a) && Number.isFinite(f.b) && Number.isFinite(f.c)){
      tA.push(t.a); tB.push(t.b); tC.push(t.c);
      fA.push(f.a); fB.push(f.b); fC.push(f.c);
    }
  }

  if (!tA.length){
    leadEl.textContent = '⚠️ No valid rows after parsing numbers.';
    return;
  }

  // 4) Limit to ~50 dots
  const LIMIT = 50;
  const idxT = randomSampleIndices(tA.length, LIMIT);
  const idxF = randomSampleIndices(fA.length, LIMIT);
  const pick = (arr, idxs) => idxs.map(i => arr[i]);
  const tA50 = pick(tA, idxT), tB50 = pick(tB, idxT), tC50 = pick(tC, idxT);
  const fA50 = pick(fA, idxF), fB50 = pick(fB, idxF), fC50 = pick(fC, idxF);

  // 5) Averages
  const avgToday  = { a: mean(tA), b: mean(tB), c: mean(tC) };
  const avgFuture = { a: mean(fA), b: mean(fB), c: mean(fC) };

  // 6) Separate average markers for clarity
  const avg2025 = {
    type: 'scatterternary',
    mode: 'markers+text',
    name: 'Average (2025)',
    a: [avgToday.a], b: [avgToday.b], c: [avgToday.c],
    text: ['Today (2025)'], textposition: 'top center',
    marker: { size: 16, symbol: 'star', color: '#22d3ee', line: { color: '#ffffff', width: 2 } }
  };

  const avg2075 = {
    type: 'scatterternary',
    mode: 'markers+text',
    name: 'Average (2075)',
    a: [avgFuture.a], b: [avgFuture.b], c: [avgFuture.c],
    text: ['Future (2075)'], textposition: 'top center',
    marker: { size: 16, symbol: 'star-diamond', color: '#c084fc', line: { color: '#ffffff', width: 2 } }
  };

  // 7) Plot all traces
  const traces = [
    { type:'scatterternary', mode:'markers', name:'Today (2025) — individuals',
      a:tA50, b:tB50, c:tC50, marker:{ size:7, opacity:0.32 }, hoverinfo:'none' },
    { type:'scatterternary', mode:'markers', name:'Future (2075) — individuals',
      a:fA50, b:fB50, c:fC50, marker:{ size:7, opacity:0.32 }, hoverinfo:'none' },
    avg2025,
    avg2075
  ];

  const layout = {
    title: 'Balance of Autonomy, Knowledge Integrity, and Equality',
    ternary: { sum: 1, aaxis:{ title:'Autonomy' }, baxis:{ title:'Equality' }, caxis:{ title:'Knowledge Integrity' } },
    paper_bgcolor:'rgba(0,0,0,0)',
    plot_bgcolor:'rgba(0,0,0,0)',
    font:{ color:'#e6edf3' },
    legend:{ orientation:'h', x:0.25, y:-0.15 }
  };

  Plotly.newPlot('aggregate-plot', traces, layout, { responsive:true });
  leadEl.textContent = `Based on ${tA.length} valid responses (showing ${tA50.length} samples per group)`;
})();
</script>
</body>
</html>
